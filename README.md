# theory-ec-regexnfa

On exam 1 and 2, I lost points do to incorrectly converting regex to NFAs. I mainly lost these points from failing to reduce to only one accept state.   
   
For my Extra Credit, I built a regex to NFA parser. This gave me a lot of practice converting regex to NFAs and I also got to focus on leaving only 1 accept state. I think this was a strong learning experience because I got to work on the principles of regex to NFA, and see how it turns out in a programming environment. I believe that I really learned how to convert all types of regex to NFAs now.   
   

The project took a lot longer than I expected it would. This mostly came from trying to format the output to be easily readable. I included functions for converting concatenation, union, kleene star, kleene plus, and any combination of them.   
   

I used a python virtual environment to hold the graphviz library, so that I could depict the NFAs I was building. To run the program, do as follows:   
in the command line, enter:   
   
source reg_to_NFA/bin/activate   
python3 regex_to_NFA.py "R1+"   
   
regex_to_NFA.py has a command line argument that takes a regex statement. It must be in quotes (to acccount for use of \*). Additionally, the language should start with an 'R', and concatenation should be split with a '.'   

For example, from Exam 1: "(R1.R2+UR3)\*" or froom Exam 2: "R1\*.(R2UR3R4+)"   
The output will show the steps taken in the console, and will generate a .png file too.   
   
The pictures/ directory contains pictures of different NFAs generated by a regex. In the pictures, the language machines are shown by two states--an accept and start. They are colored Blue for ease of understanding. All added transitions and intermediary states are red dashed or black.   